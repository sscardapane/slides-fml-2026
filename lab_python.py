# -*- coding: utf-8 -*-
"""Lab-Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LdpTkKNPrNQCycNFDYdCYgE7V3wJCNi_

## Guided lab session (Python)

### Introduction to Python

This is a (very basic) lab session for students with little or no exposition to programming and Python. Strong emphasis is given to concepts that are useful for developing with NumPy and/or PyTorch, including basic data structures (lists, dictionaries, tuples) and object-oriented programming.

> âš  All exercises are very simple - I **strongly** suggest to disable Gemini completions for now.

### Basics
"""

# Assignment to a variable (variables should be lowercase). The last operation
# is interpreted as a print.
a = 5
a

# Some basic types (floating point, strings, integers, Booleans)
print(4.2)
print('cat')
print(4 == 3)

"""### Section 1: Lists

A list is an (heterogenous) collection of elements. Lists in Python are defined by square brackets [ ... ] and can be manipulated by adding / removing elements, indexing single elements, and iterating over them. See the docs: https://docs.python.org/3/tutorial/datastructures.html.
"""

# A list with three elements (of three different types)
new_list = ['a', 1, 4.5]

# Basic indexing
print(new_list[0])
print(new_list[1])
print(new_list[-1])

# Less basic indexing
print(new_list[0:2])
print(new_list[0::2])
print(new_list[-1:-6:-1])

"""> **TODO**: Write a code to print all elements between 1/3 and 2/3 of the length of the list (hint: you might need to use `floor` and `ceil`)."""

from math import floor, ceil
int_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
# TODO

# Lists can be iterated over
for x in new_list:
  print(x)

"""For our purposes, we are especially interested in [list comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions), operations that create new lists from old lists by iterating over their elements."""

# Select all integers
print([x for x in new_list if type(x) == int])

# range allows us to create lists of indices. Note how a for-loop can work with
# any "iterable" object.
for i in range(len(new_list)):
  print(new_list[i])

# zip allows us to iterate over two lists simultaneously
for i, x in zip(range(len(new_list)), new_list):
  print(f'{i}: {x}')

# enumerate is an alias for the previous example
for i, x in enumerate(new_list):
  print(f'{i}: {x}')

"""> **TODO**: In the following cell, write a list comprehension such that the $i$-th element of the first list is multiplied with the $n-i$-th element from the second list (i.e., each element is multiplied by an element of the second list taken in reverse)."""

first_list = [1, 2, 3, 4]
second_list = [10, 20, 30, 40]
# TODO: complete the snippet

# Modify a list - this is a function with "side effects", as it modifies the underlying
# object instead of returning it (also known as an in-place operation).
first_list.append(15)

# Operators in Python are "polymorphic" - their behaviour depends on the data types
# on which they are applied.
first_list + [18, 21]

# Another example of polymorphism
first_list*3

"""> **TODO**: Write a list comprehension that returns all elements larger than 2, multiplied by 3."""

my_list = [3, 0, 2, 1, 5]
# TODO

"""### Section 2: Other interesting containers"""

# Tuples, differently, from lists, cannot be modified after being initialized.
('first', 'name')

# Dictionaries are composed of (key, value) pairs. A list can be understood as a dictionary
# where the key is an integer.
activities = {
    7: 'Sleeping',
    9: 'Commuting',
    11: 'Working',
    14: 'Eating',
    15: 'Working',
    18: 'Relaxing'
}

activities[7]

# Adding a new value to the dictionary
activities[22] = 'Movie'

# We can iterate in many ways over dictionaries:
for key in activities:
  print(f'{key}: {activities[key]}')

for key, value in activities.items():
  print(f'{key}: {value}')

for value in activities.values():
  print(value)

"""> **TODO**: Write a list comprehension that returns all activities done in a certain interval."""

min_hour, max_hour = 10, 19
# TODO

"""### Section 3: Functions

Functions encapsulate "parametric" behaviour, as they return output conditional on the provided input. Because Python is "weakly typed", functions only specify the name of the parameters and not their types ("hints" are possible but not mandatory).
"""

def what_am_i_doing(activities: dict, hour: int) -> str:
  for act in activities:
    if hour <= act:
      return activities[act]

print(what_am_i_doing(activities, 7))
print(what_am_i_doing(activities, 8))
print(what_am_i_doing(activities, 16))

# "Inline" functions can be defined for functions that can be defined in a single line.
shift_by_one = lambda x: x + 1

shift_by_one(3)

# Python has a wide set of modules that can be imported
import time
time.localtime()

# Localized import
from time import localtime

localtime().tm_hour

"""> **TODO**: After reading about [argument types](https://www.w3schools.com/python/python_functions.asp) in Python, modify the previous function so that "hour" is optional, and if not provided, the function returns the activity at the current time."""

# TODO
def what_am_i_doing_v2(...)

what_am_i_doing_v2(activities)

"""### Section 4: Classes and objects

Classes in Python allows to encapsulate data and methods in a single item. The class can be "instantiated" based on some initial parameters to create an "object".
"""

class ActivityLog():
  def __init__(self, activities: dict):
    self.activities = activities

  def what_am_i_doing(self, hour: int) -> str:
    for act in self.activities:
      if hour <= act:
        return self.activities[act]

logger = ActivityLog(activities)
print(logger.what_am_i_doing(12))